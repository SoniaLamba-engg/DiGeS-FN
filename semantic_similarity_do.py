# -*- coding: utf-8 -*-
"""Semantic Similarity DO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CszgXlXjOgV2IE_11vSoZO3OGAwYsQ4V
"""

import networkx as nx
import matplotlib.pyplot as plt

def create_disease_ontology_dag():
    # Create a new directed graph
    graph = nx.DiGraph()

    # Read the disease ontology dataset
    with open('doid.obo', 'r') as file:
        lines = file.readlines()

    term_id = None

    # Process each line in the dataset
    for line in lines:
        line = line.strip()

        if line.startswith('[Term]'):
            if term_id:
                # Add the term to the graph
                graph.add_node(term_id, name=name)

            # Reset the variables for the new term
            term_id = None
            name = None
        elif line.startswith('id:'):
            term_id = line.split(': ')[1]
        elif line.startswith('name:'):
            name = line.split(': ')[1]
        elif line.startswith('is_a:'):
            parent_id = line.split(': ')[1].split(' ! ')[0]
            # Add an edge to represent the "is_a" relationship
            graph.add_edge(term_id, parent_id)

    # Add the last term to the graph
    if term_id:
        graph.add_node(term_id, name=name)

    return graph

# Create the disease ontology DAG
disease_ontology_dag = create_disease_ontology_dag()

# Visualize the DAG
pos = nx.spring_layout(disease_ontology_dag)
nx.draw_networkx(disease_ontology_dag, pos, with_labels=True, node_size=1000, node_color='lightblue',
                 font_size=10, font_weight='bold', edge_color='gray')
plt.axis('off')
plt.show()

# Get the number of nodes and edges
num_nodes = disease_ontology_dag.number_of_nodes()
num_edges = disease_ontology_dag.number_of_edges()

print("Number of nodes:", num_nodes)
print("Number of edges:", num_edges)

indegree = disease_ontology_dag.in_degree('DOID:8956')
outdegree = disease_ontology_dag.out_degree('DOID:8956')
print("Indegree:", indegree)
print("Outdegree", outdegree)

def count_disease_ids(dataset_path):
    disease_ids = set()

    with open(dataset_path, 'r') as file:
        lines = file.readlines()

    for line in lines:
        line = line.strip()
        if line.startswith('[Term]'):
            term_id = None
        elif line.startswith('id: DOID:'):
            term_id = line.split(' ')[1]
            disease_ids.add(term_id)

    return len(disease_ids)

# Path to the Disease Ontology dataset (8.0 version)
dataset_path = 'doid.obo'

# Count the number of disease IDs
num_disease_ids = count_disease_ids(dataset_path)

print(f"Number of disease IDs in Disease Ontology (8.0 version): {num_disease_ids}")

def all_descendant_nodes(dag, node):
    descendants = set()
    for successor in dag.successors(node):
        descendants.add(successor)
        descendants |= all_descendant_nodes(dag, successor)
    return descendants

node_to_find_descendants = 'DOID:8956'
all_descendants = all_descendant_nodes(disease_ontology_dag, node_to_find_descendants)

print(f"All descendant nodes of node {node_to_find_descendants} up to the root node(s): {all_descendants}")

node_to_find_descendants = 'DOID:594'
all_descendants = all_descendant_nodes(disease_ontology_dag, node_to_find_descendants)

print(f"All descendant nodes of node {node_to_find_descendants} up to the root node(s): {all_descendants}")

from google.colab import files
# Upload a single file
uploaded = files.upload()

import pandas as pd
import math

def calculate_IC(n, N):

    if n == 0 or N == 0:
        return 0.0
    return -math.log(n / N)

def calculate_IC_values_from_excel(file_path):

    # Read the Excel file into a pandas DataFrame
    df = pd.read_excel(file_path)

    # Calculate the total number of genes (N)
    total_genes_count = 10347

    # Create a dictionary to store the 'n' (gene count) for each disease
    disease_gene_counts = {}

    # Calculate 'n' for each disease term
    for disease_term in df['Disease ID'].unique():
        n = df[df['Disease ID'] == disease_term]['Gene Symbol'].nunique()
        disease_gene_counts[disease_term] = n
        print(f"Disease Term: {disease_term}, Genes Related: {n}")

    # Calculate the Information Content (IC) for each disease term
    ic_values = {}
    for disease_term, n in disease_gene_counts.items():
        N = total_genes_count
        ic_values[disease_term] = calculate_IC(n, N)
    print(f"Total Gene Count: {N}")
    return ic_values

# Replace 'your_file.xlsx' with the path to your Excel file
file_path = '/content/newest disease gene interactions only.xlsx'

# Get the Information Content (IC) values for each disease term
ic_values_dict = calculate_IC_values_from_excel(file_path)

# Print the Information Content (IC) values for each disease term
for disease_term, ic_value in ic_values_dict.items():
    print(f"Disease: {disease_term}, IC: {ic_value}")

# Create a DataFrame to store the disease IDs and their corresponding IC values
ic_df = pd.DataFrame(list(ic_values_dict.items()), columns=['Disease ID', 'IC Value'])

# Export the DataFrame to an Excel file
ic_df.to_excel('/content/ic_values.xlsx', index=False)

from google.colab import files
# Upload a single file
uploaded = files.upload()

ic_values_df = pd.read_excel('newest_ic_values.xlsx')
print(ic_values_df)

def find_common_ancestor(dag, term1, term2, ic_values_df):
    # Get the IC values for each term

    descendants1 = set()
    for successor in dag.successors(term1):
        descendants1.add(successor)
        descendants1 |= all_descendant_nodes(dag, successor)
        print(f"All ancestors of {term1} : {descendants1}")

    descendants2 = set()
    for successor in dag.successors(term2):
        descendants2.add(successor)
        descendants2 |= all_descendant_nodes(dag, successor)
        print(f"All ancestors of {term2} : {descendants2}")

    common_ancestors = descendants1.intersection(descendants2)

    if len(common_ancestors) == 0:
        print("None")
    else:
        max_ic = -1  # Initialize max_ic with a minimum value
        max_ic_ancestor = None  # Initialize max_ic_ancestor
        for ancestor in common_ancestors:
            print(f"Common Ancestors for {term1} and {term2} are-", ancestor)

            # Check if the ancestor is in the IC values DataFrame
            if ancestor in ic_values_df['Disease ID'].values:
                ic_value = ic_values_df.loc[ic_values_df['Disease ID'] == ancestor, 'IC Value'].values[0]
                if ic_value > max_ic:
                    max_ic = ic_value
                    max_ic_ancestor = ancestor

                # Print IC values for all common ancestors
                print(f"Ancestor: {ancestor}, IC Value: {ic_value}")

        if max_ic_ancestor is not None:
            print(f"Most informative common ancestor: {max_ic_ancestor}, Max IC Value: {max_ic}")

# Define the disease terms
term1 = 'DOID:5419'
term2 = 'DOID:13809'

# Assuming you have a DataFrame named ic_values_df
# Find the most informative common ancestor
common_ancestor = find_common_ancestor(disease_ontology_dag, term1, term2, ic_values_df)

file_path_true_labels = '/content/true values.xlsx'

import pandas as pd
df_true_labels = pd.read_excel(file_path_true_labels, index_col=0)

df_true_labels.head()

file_path_predicted_values = '/content/calculated values DO.xlsx'

df_predicted_values = pd.read_excel(file_path_predicted_values, index_col=0)

df_predicted_values.head()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

def build_roc_curve(true_labels, predicted_values):
    # Flatten the matrices to 1D arrays
    true_labels = np.ravel(true_labels)
    predicted_values = np.ravel(predicted_values)

    # Compute the ROC curve
    fpr, tpr, thresholds = roc_curve(true_labels, predicted_values)

    # Compute the area under the ROC curve (AUC)
    roc_auc = auc(fpr, tpr)

    # Plot the ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='blue', lw=2, label='ROC curve (AUC = {:.2f})'.format(roc_auc))
    plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend(loc='lower right')
    plt.grid(True)
    plt.show()

# Load data from Excel files
file_path_true_labels = '/content/true values.xlsx'
file_path_predicted_values = '/content/calculated values DO.xlsx'

df_true_labels = pd.read_excel(file_path_true_labels, index_col=0)
df_predicted_values = pd.read_excel(file_path_predicted_values, index_col=0)


# Convert the DataFrames to numpy arrays
true_labels = df_true_labels.values
predicted_values = df_predicted_values.values

# Call the function to build and plot the ROC curve
build_roc_curve(true_labels, predicted_values)

"""Normalizing Calculated Values Using MIN MAX Normalization Technique

"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
actual_df= pd.read_excel(io.BytesIO(uploaded['true positives updated.xlsx'])).set_index('DOID')
print(actual_df)

from google.colab import files
uploaded = files.upload()

