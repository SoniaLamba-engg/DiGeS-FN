# -*- coding: utf-8 -*-
"""Jaccard Similarity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oi9eiKNbJl5y2G_6PicZ9GjEUtUKjQsl
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
disease_gene = pd.read_excel(io.BytesIO(uploaded['disease_info_new_latest_updated.xlsx']))
print(disease_gene)

import pandas as pd
import numpy as np
from itertools import combinations

# Convert gene counts to sets
disease_gene['Gene_Set'] = disease_gene['Related Genes'].str.split(',').apply(set)

def jaccard_similarity(set1, set2):
    set_A = len(set1)
    set_B = len(set2)
    intersection = len(set1.intersection(set2))
    union = len(set1.union(set2))
    return intersection / union if union != 0 else 0

disease_names = disease_gene['Disease ID'].tolist()
num_diseases = len(disease_names)

# Initialize a matrix to store Sorensen similarities
similarity_matrix = np.zeros((num_diseases, num_diseases))

for i, disease1 in enumerate(disease_names):
    set1 = disease_gene[disease_gene['Disease ID'] == disease1]['Gene_Set'].iloc[0]
    for j, disease2 in enumerate(disease_names):
        if i != j:  # Avoid comparing a disease to itself
            set2 = disease_gene[disease_gene['Disease ID'] == disease2]['Gene_Set'].iloc[0]
            similarity = jaccard_similarity(set1, set2)
            similarity_matrix[i, j] = similarity


# Display the Sorensen similarity matrix
jaccard_df = pd.DataFrame(similarity_matrix, index=disease_names, columns=disease_names)
print("Jaccard Similarity Matrix:")
print(jaccard_df)

# Export the Jaccard similarity matrix to a CSV file
jaccard_df.to_csv('jaccard_similarity_new_latest.csv')

import numpy as np
from sklearn.metrics import roc_curve, auc, accuracy_score
import matplotlib.pyplot as plt

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
predicted_df = pd.read_csv(io.BytesIO(uploaded['JS.csv'])).set_index('DOID')
print(predicted_df)

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
true_df = pd.read_excel(io.BytesIO(uploaded['true positives.xlsx'])).set_index('DOID')
print(true_df)

"""ROC Curve"""

import numpy as np
import pandas as pd
from sklearn.metrics import roc_curve, auc, accuracy_score
import matplotlib.pyplot as plt

# Initialize lists to store ROC AUC scores and accuracies for each disease
roc_auc_scores = []
best_thresholds = []
max_accuracies = []

# Calculate ROC curve, AUC, and accuracy for each disease
for disease_column in predicted_df.columns:
    fpr, tpr, thresholds = roc_curve(true_df[disease_column], predicted_df[disease_column])
    roc_auc = auc(fpr, tpr)
    roc_auc_scores.append(roc_auc)

    # Find the threshold that maximizes accuracy
    accuracies = []
    for threshold in thresholds:
        predicted_labels = (predicted_df[disease_column] >= threshold).astype(int)
        accuracy = accuracy_score(true_df[disease_column], predicted_labels)
        accuracies.append(accuracy)

    best_threshold = thresholds[np.argmax(accuracies)]
    best_thresholds.append(best_threshold)
    max_accuracies.append(max(accuracies))

    # Plot ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'{disease_column} (AUC = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title(f'ROC Curve for {disease_column}')
    plt.legend(loc="lower right")

# Print results for each disease
for idx, (disease_column, roc_auc, threshold, accuracy) in enumerate(zip(predicted_df.columns, roc_auc_scores, best_thresholds, max_accuracies)):
     print(f'{disease_column} - ROC AUC: {roc_auc:.2f}, Best Threshold: {threshold:.2f}, Max Accuracy: {accuracy:.2f}')

plt.show()

"""Setting the threshold value"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
similarity_matrix = pd.read_excel(io.BytesIO(uploaded['JS.xlsx']))
print(similarity_matrix)

import pandas as pd
import numpy as np

# Assuming your similarity matrix is a DataFrame named 'similarity_matrix'
# Replace 'similarity_matrix' with your actual DataFrame variable

threshold_value = 0.06  # Set your desired threshold here

# Extract the numeric part of the matrix
numeric_matrix = similarity_matrix.iloc[:, 1:].values.astype(float)

# Apply thresholding
thresholded_matrix = np.where(numeric_matrix >= threshold_value, 1, 0)

# Create a new DataFrame from the thresholded matrix with the same index and columns
thresholded_df = pd.DataFrame(thresholded_matrix, index=similarity_matrix.index, columns=similarity_matrix.columns[1:])

# Display the thresholded DataFrame
print(thresholded_df)

thresholded_df.to_excel('thresholded_values4446.xlsx')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

def build_roc_curve(true_labels, predicted_values):
    # Flatten the matrices to 1D arrays
    true_labels = np.ravel(true_labels)
    predicted_values = np.ravel(predicted_values)

    # Compute the ROC curve
    fpr, tpr, thresholds = roc_curve(true_labels, predicted_values)

    # Compute the area under the ROC curve (AUC)
    roc_auc = auc(fpr, tpr)

    # Plot the ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='blue', lw=2, label='ROC curve (AUC = {:.2f})'.format(roc_auc))
    plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('ROC Curve For Jaccard Similarity')
    plt.legend(loc='lower right')
    plt.grid(True)
    plt.show()

# Load data from Excel files
file_path_true_labels = '/content/true positives.xlsx'
file_path_predicted_values = '/content/thresholded_values4446.xlsx'

df_true_labels = pd.read_excel(file_path_true_labels, index_col=0)
df_predicted_values = pd.read_excel(file_path_predicted_values, index_col=0)


# Convert the DataFrames to numpy arrays
true_labels = df_true_labels.values
predicted_values = df_predicted_values.values

# Call the function to build and plot the ROC curve
build_roc_curve(true_labels, predicted_values)

"""Normalizing Calculated Similarity Values Using MIN MAX Normalization Technique"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
actual_df= pd.read_excel(io.BytesIO(uploaded['true positives updated.xlsx'])).set_index('DOID')
print(actual_df)

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
similarity_matrix_jaccard= pd.read_excel(io.BytesIO(uploaded['JS.xlsx'])).set_index('DOID')
print(similarity_matrix_jaccard)

import pandas as pd
import io

# Assuming similarity_matrix_semfunsim is already loaded

# Min-Max normalization function
def min_max_normalize(matrix):
    matrix_array = matrix.values.astype(float)
    min_val = matrix_array.min()
    print(min_val)
    max_val = matrix_array.max()
    print(max_val)
    normalized_matrix = (matrix_array - min_val) / (max_val - min_val)
    return normalized_matrix

# Normalize the similarity matrix
normalized_similarity_matrix = min_max_normalize(similarity_matrix_jaccard)

# Create a DataFrame for the normalized matrix
normalized_df = pd.DataFrame(normalized_similarity_matrix, columns=similarity_matrix_jaccard.columns, index=similarity_matrix_jaccard.index)

# Export the normalized matrix to an Excel file
normalized_df.to_excel("normalized_matrix_jaccard.xlsx")

# Display the normalized matrix DataFrame
print("Normalized Similarity Matrix:")
print(normalized_df)

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
predicted_df= pd.read_excel(io.BytesIO(uploaded['normalized_matrix_jaccard (1).xlsx'])).set_index('DOID')
print(predicted_df)

import pandas as pd
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Assuming you have actual_df and predicted_df dataframes

# Combine the actual and predicted values for each pair of diseases
actual_values = actual_df.values.flatten()
predicted_values = predicted_df.values.flatten()

# Compute the ROC curve
fpr, tpr, thresholds = roc_curve(actual_values, predicted_values)

# Compute the Area Under the Curve (AUC)
roc_auc = auc(fpr, tpr)

# Plot the ROC curve
plt.figure(figsize=(10, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Jaccard Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc='lower right')
plt.show()

